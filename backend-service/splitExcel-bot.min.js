import{readFileSync,writeFileSync,statSync,mkdirSync,rmSync,existsSync}from"fs";import sodium from"libsodium-wrappers";import{Octokit}from"@octokit/rest";import{createHash}from"crypto";import{createAppAuth}from"@octokit/auth-app";import fs from"fs";let octokit;function getGitHubAppPrivateKey(providedKey,providedKeyPath){if(providedKeyPath)try{return fs.readFileSync(providedKeyPath,"utf8")}catch(error){console.warn(`WARN (splitExcel-bot): GITHUB_APP_PRIVATE_KEY_PATH is set but could not read file (${providedKeyPath}):`,error.message),console.warn("WARN (splitExcel-bot): Falling back to provided GITHUB_APP_PRIVATE_KEY.")}if(providedKey)return providedKey;throw new Error("Missing GitHub App private key in config for splitExcel-bot.")}async function initializeOctokit(appId,privateKey,privateKeyPath,installationId){const effectivePrivateKey=getGitHubAppPrivateKey(privateKey,privateKeyPath);if(!appId||!effectivePrivateKey||!installationId)throw new Error("Missing appId, privateKey/privateKeyPath, or installationId for GitHub App authentication in splitExcel-bot.");try{const auth=createAppAuth({appId:appId,privateKey:effectivePrivateKey.replace(/\\\\n/g,"\\n"),installationId:installationId}),installationAuthentication=await auth({type:"installation"});octokit=new Octokit({auth:installationAuthentication.token}),console.log("Octokit initialized successfully using GitHub App credentials.")}catch(error){throw console.error("Error initializing Octokit with GitHub App:",error),error}}import{NUM_CHUNKS}from"./config.js";const TEMP_DIR="./.temp";async function processFile(filePath,secretPrefix,githubConfig){try{console.log(`\nüìÑ Processing file: ${filePath}`);const originalSize=statSync(filePath).size;if(0===originalSize)throw new Error(`‚ùå Error: ${filePath} is empty`);const fileBuffer=readFileSync(filePath),chunkSize=Math.ceil(fileBuffer.length/NUM_CHUNKS),base64Chunks=[],originalHash=createHash("sha256").update(fileBuffer).digest("hex");console.log(`üîí Original file hash: ${originalHash}`),console.log(`üìä Original file size: ${originalSize} bytes`);const chunks=[];let totalSize=0;for(let i=0;i<NUM_CHUNKS;i++){const start=i*chunkSize,end=Math.min(start+chunkSize,fileBuffer.length),chunk=fileBuffer.subarray(start,end),chunkPath=`${TEMP_DIR}/${secretPrefix}_chunk_${i}`;writeFileSync(chunkPath,chunk);const writtenSize=statSync(chunkPath).size;chunks.push(chunk),totalSize+=chunk.length,console.log(`üì¶ Chunk ${i+1}:`),console.log(`   Size: ${chunk.length} bytes`),console.log(`   Written size: ${writtenSize} bytes`);const secretName=`${secretPrefix}_CHUNK_${i+1}`,secretValue=Buffer.from(chunk).toString("base64");base64Chunks.push(secretValue);const decodedSize=Buffer.from(secretValue,"base64").length;if(decodedSize!==chunk.length)throw new Error(`Base64 validation failed for chunk ${i+1}! Original: ${chunk.length}, Decoded: ${decodedSize}`);console.log(`   Base64 length: ${secretValue.length}`),console.log("   Decoded size matches: ‚úÖ"),await updateGithubSecret(secretName,secretValue,githubConfig)}const decodedChunks=base64Chunks.map((str=>Buffer.from(str,"base64"))),combinedBuffer=Buffer.concat(decodedChunks),finalHash=createHash("sha256").update(combinedBuffer).digest("hex");if(console.log("\nüîç Final validation:"),console.log(`   Original size: ${originalSize} bytes`),console.log(`   Final size: ${combinedBuffer.length} bytes`),console.log(`   Original hash: ${originalHash}`),console.log(`   Final hash: ${finalHash}`),console.log("   Hashes match: "+(originalHash===finalHash?"‚úÖ":"‚ùå")),totalSize!==originalSize)throw new Error(`Size mismatch after splitting! Original: ${originalSize}, Chunks total: ${totalSize}`);return console.log(`‚úÖ Successfully split file into ${NUM_CHUNKS} chunks`),console.log("üîç Validations passed:"),console.log(`   - Original size: ${originalSize} bytes`),console.log(`   - Total chunks size: ${totalSize} bytes`),console.log("   - All chunks properly base64 encoded"),!0}catch(error){return console.error(`‚ùå Error processing ${filePath}:`,error),!1}}async function updateGithubSecret(secretName,secretValue,githubConfig){const{owner:owner,repo:repo}=githubConfig;try{const{data:publicKey}=await octokit.actions.getRepoPublicKey({owner:owner,repo:repo}),secretBytes=Buffer.from(secretValue),keyBytes=Buffer.from(publicKey.key,"base64");await sodium.ready;const encryptedBytes=sodium.crypto_box_seal(secretBytes,keyBytes),encrypted=Buffer.from(encryptedBytes).toString("base64");await octokit.actions.createOrUpdateRepoSecret({owner:owner,repo:repo,secret_name:secretName,encrypted_value:encrypted,key_id:publicKey.key_id}),console.log(`‚úÖ Updated secret: ${secretName}`)}catch(error){throw console.error(`‚ùå Failed to update secret ${secretName}:`,error),error}}async function main(filePath,secretPrefix,githubConfig){const{appId:appId,privateKey:privateKey,privateKeyPath:privateKeyPath,installationId:installationId,owner:owner,repo:repo}=githubConfig;if(!(appId&&(privateKey||privateKeyPath)&&installationId&&owner&&repo))throw console.error("‚ùå Missing required GitHub configuration parameters: appId, (privateKey or privateKeyPath), installationId, owner, or repo"),new Error("Missing GitHub configuration parameters for splitExcel-bot");try{await initializeOctokit(appId,privateKey,privateKeyPath,installationId),existsSync(TEMP_DIR)||mkdirSync(TEMP_DIR,{recursive:!0});const success=await processFile(filePath,secretPrefix,githubConfig);if(!success)throw console.error(`\n‚ùå File ${filePath} failed to process with prefix ${secretPrefix}`),new Error(`Failed to process file ${filePath}`);return console.log(`\nüéâ File ${filePath} processed successfully with prefix ${secretPrefix}!`),console.log("üîë All secrets updated on GitHub"),success}catch(error){throw console.error("‚ùå Error in main processing:",error),error}finally{try{existsSync(TEMP_DIR)&&(console.log("\nüßπ Cleaning up..."),rmSync(TEMP_DIR,{recursive:!0,force:!0}),console.log("üßπ Cleaned up temporary files"))}catch(cleanupError){console.error("‚ùå Failed to clean up temp directory:",cleanupError)}}}export{main};